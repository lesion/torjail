#!/bin/bash

# Copyright (C) 2018 - underscore@autistici.org
# This work is free. You can redistribute it and/or modify it under the
# terms of the Do What The Fuck You Want To Public License, Version 2,
# as published by Sam Hocevar. See the COPYING file for more details.

REALPATH=$(realpath "$0")
REALPATH=$(dirname "$REALPATH")
DEFAULTNAME=orjail
NAME=$DEFAULTNAME
USERNAME=${SUDO_USER:-$(whoami)}
USEFIREJAIL=n
FIREJAILARGS=
VERBOSE=
TORBIN=
KEEP=
HIDDENSERVICE=
HIDDENSERVICEDIR=
IPHOSTDEFAULT=10.200.1.1
IPHOST=$IPHOSTDEFAULT
IPNETNSDEFAULT=10.200.1.2
IPNETNS=$IPNETNSDEFAULT
NETMASKDEFAULT=24
NETMASK=$NETMASKDEFAULT
TRANSPORT=9040
DNSPORT=5354
SUDOBIN="$(command -v sudo)"
NOSETUPERROR=n

# Functions
# ~~~~~~~~~

print_real() {
  if [ "$VERBOSE" != y ]; then
    return
  fi

  if [ -t 1 ]; then
    NCOLORS=$(tput colors)

    if test -n "$NCOLORS" && test "$NCOLORS" -ge 8; then
      NORMAL="$(tput sgr0)"
      RED="$(tput setaf 1)"
      GREEN="$(tput setaf 2)"
      YELLOW="$(tput setaf 3)"
    fi
  fi

  if [[ $2 = 'G' ]]; then
    # shellcheck disable=SC2086
    echo $1 -e "${GREEN}$3${NORMAL}"
  elif [[ $2 = 'Y' ]]; then
    # shellcheck disable=SC2086
    echo $1 -e "${YELLOW}$3${NORMAL}"
  elif [[ $2 = 'N' ]]; then
    # shellcheck disable=SC2086
    echo $1 -e "$3"
  else
    # shellcheck disable=SC2086
    echo $1 -e "${RED}$3${NORMAL}"
  fi
}

print() {
  print_real '' "$1" "$2"
}

printn() {
  print_real "-n" "$1" "$2"
}

printv() {
  OLDVERBOSE=$VERBOSE
  VERBOSE=y
  print_real '' "$1" "$2"
  VERBOSE=$OLDVERBOSE
}

printvn() {
  OLDVERBOSE=$VERBOSE
  VERBOSE=y
  print_real "-n" "$1" "$2"
  VERBOSE=$OLDVERBOSE
}

# exec no output
eno() {
  if [ "$VERBOSE" != y ]; then
    "$@" &>/dev/null
  else
    "$@"
  fi
}

# kill tor, remove network namespace, cleanup added iptables rules
cleanup() {
  if [ "$NOSETUPERROR" != y ]; then
    ERROR_COMMAND=$(eval echo "${BASH_COMMAND//\"/\\\"}")
    printv R "[Error] $ERROR_COMMAND"
  fi
  set +e

  TORPID=$(cat /tmp/orjail-"$NAME"/pid 2> /dev/null)
  if [ "$KEEP" = y ]; then
    print G " * Keep Tor process $TORPID running"
    print G " * Keep $NAME namespace active"
  else
    print G " * Remove Tor temporary configuration"
    eno rm "$TORCONFIGFILE"
    print G " * Killing Tor process $TORPID"
    eno kill -9 "$TORPID"
    eno wait $!
    print G " * Killed $TORPID"

    print G " * Remove Tor DataDirectory: /tmp/orjail-$NAME"
    eno rm -fr /tmp/orjail-"$NAME"

    print G " * Remove in-$NAME network interface"
    eno ip link del in-"$NAME"

    print G " * Delete network namespace $NAME"
    eno ip netns delete "$NAME"

    print G " * Cleaning up iptables rules..."
    iptables -S | grep \\b"in-$NAME"\\b | while read -r line; do
      # shellcheck disable=SC2086
      iptables ${line//-A/-D} &>/dev/null;
    done
    iptables -t nat -S | grep \\b"in-$NAME"\\b | while read -r line; do
      # shellcheck disable=SC2086
      iptables -t nat ${line//-A/-D} &>/dev/null;
    done


  fi

  if [ ! -z "$RESOLVEFILE" ]; then
  print G " * Remove the temporary resolve file $RESOLVEFILE..."
  eno rm "$RESOLVEFILE"
  fi
}

error() {
  printv R "$1"
}

die() {
  error "$1"
  exit 1
}

help_and_exit() {
  VERBOSE=y
  printn N "Usage: "
  printn Y "$DEFAULTNAME"
  print G " <options> [command <arguments>...]"
  print N "Options:"
  print N "    -h, --help         It shows this menu."
  print N "    -u, --user <user>  Execute the command with this user permission. By default '$USERNAME'."
  print N "    -n, --name <name>  Set a custom namespace name. By default '$DEFAULTNAME'."
  print N "    -v, --verbose      Verbose mode."
  print N "    -k, --keep         Don't delete namespace and don't kill tor after the execution."
  print N "    -f, --firejail     Use firejail as a security container ($SUDOBIN orjail -f pidgin)."
  print N "        --firejail-args \"<args>\""
  print N "                       Set arguments to pass to firejail surrounded by quotes."
  print N "    -H, --hidden <port>"
  print N "                       Enable Tor as an hidden service forwarding request from/to specified port."
  print N "    -d, --hiddendir <dir>"
  print N "                       Specify where to search for hidden service 'hostname' and 'private_key'."
  print N "    -s, --shell        Execute a shell."
  print N "    -r, --routing <ip_host> <ip_ns> <netmask>"
  print N "                       Set custom IPs. By default $IPHOSTDEFAULT/$IPNETNSDEFAULT/$NETMASKDEFAULT."
  print N "        --trans-port <port>"
  print N "                       Set tor TransPort. By default $TRANSPORT"
  print N "        --dns-port <port>"
  print N "                       Set custom DnsPort. By default $DNSPORT"
  print N "        --port-range <port>-<port>"
  print N "                       Generate random TransPort and DnsPort in the defined range."
  exit "$1"
}

# Inside part
# ~~~~~~~~~~~

# This script calls itself. yeah \o/ This part is executed only inside the
# namespace. The arguments are:
# --inside <username> <resolvefile> <verbose> <command> <arguments...>
if [ "$1" = "--inside" ]; then
  REALPATH=$(realpath "$0")
  REALPATH=$(dirname "$REALPATH")

  shift
  USERNAME="$1"
  shift
  RESOLVEFILE="$1"
  shift
  VERBOSE="$1"
  shift

  print G " * Replacing resolv.conf..."
  mount --bind -o users "$RESOLVEFILE" /etc/resolv.conf || \
    error "Failed to mount /etc/resolv.conf."

  print G " * Executing..."

  if [ "$SUDOBIN" ]; then
    $SUDOBIN -u "$USERNAME" "$@"
  else
    su "$USERNAME" -c "$*"
  fi
  exit
fi

# The tool
# ~~~~~~~~

# exit on error, and call cleanup on exit
set -e
trap cleanup EXIT

# Arguments check
while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    # Replacing the name
    -n|--name)
      NAME="$2"
      shift

      if [ "$NAME" = "" ]; then
        die "$key requires an argument."
      fi
    ;;

    # Username
    -u|--username)
      USERNAME="$2"
      shift

      if [ "$USERNAME" = "" ]; then
        die "$key requires an argument."
      fi
    ;;

    -v|--verbose)
      VERBOSE=y
      ;;

    -k|--keep)
      KEEP=y
      ;;

    -H|--hidden)
      HIDDENSERVICE=y
      HSERVICEPORT="$2"
      shift

      if [ "$HSERVICEPORT" = "" ]; then
        die "$key requires an argument."
      fi
      ;;

    -d|--hiddendir)
      HIDDENSERVICEDIR="$2"
      shift

      if [ "$HIDDENSERVICEDIR" = "" ]; then
        die "$key requires an argument."
      fi
      ;;

    -r|--routing)
      IPHOST="$2"
      shift
      IPNETNS="$2"
      shift
      NETMASK="$2"
      shift

      if [ "$IPHOST" = "" ] ||
         [ "$IPNETNS" = "" ] ||
         [ "$NETMASK" = "" ]; then
        die "$key requires 3 arguments."
      fi
      ;;

    -f|--firejail)
      USEFIREJAIL=y
      ;;

    --firejail-args)
      FIREJAILARGS=( "$2" )
      shift

      if [ "${#FIREJAILARGS[@]}" -eq 0 ]; then
        die "$key requires an argument."
      fi
      USEFIREJAIL=y
      ;;

    -s|--shell)
      set -- "$@" "$SHELL"
      ;;

    # TransPort
    --trans-port)
      TRANSPORT="$2"
      shift
      [ "$TRANSPORT" ] || die "$key requires an argument."
    ;;

     # DnsPort
    --dns-port)
      DNSPORT="$2"
      shift
      [ "$DNSPORT" ] || die "$key requires an argument."
    ;;

     # PortRange
    --port-range)
      range="$2"
      shift

      [ "$range" ] || die "$key requires an argument."

      if ! [[ "$range" =~ [0-9]{2,5}-[0-9]{2,5} ]]; then
        die "port range should be like 1000-9000."
      fi

      # disabled bacause read -a and mapfile are not available in zsh
      # shellcheck disable=SC2207
      rnd_range=( $(shuf -i "$range" -n 2) )
      TRANSPORT="${rnd_range[0]}"
      DNSPORT="${rnd_range[1]}"

      printv G "random generated TransPort: $TRANSPORT"
      printv G "random generated DnsPort: $DNSPORT"
    ;;

    # Help menu
    -h|--help)
      help_and_exit 0
    ;;

    # End my options
    --)
      shift
      break
    ;;

    # Illegal options
    -*)
      die "$key unknown option."
    ;;

    # The rest
    *)
    break
    ;;
  esac
  shift
done

if [[ $EUID -ne 0 ]]; then
   die "$DEFAULTNAME must be run as root."
fi

TORBIN=$(command -v tor)
if ! [ -x "$TORBIN" ]; then
  die "Can't locate tor executable.";
fi

# No arguments, no party
if [ "$1" = "" ]; then
  help_and_exit 1
fi

# Check linux kernel
if [ "$(uname)" != "Linux" ]; then
  die "No Linux no party"
fi

FIREJAILBIN=
if [ $USEFIREJAIL = y ]; then
  firejail_version=$(firejail --version | grep -io "9.[0-9]\\{2\\}")
  if [[ $(echo "$firejail_version>9.44" | bc) -eq 0 ]]; then
	  die "orjail requires at least firejail 0.99.44.10 to run."
  fi

  FIREJAILBIN=firejail
fi

err=0
for cmd in ip iptables $FIREJAILBIN ${SUDOBIN:-su}; do
  if ! [ -x "$(command -v "$cmd")" ]; then
    printv R "Cannot locate $cmd executable"
    err=1
  fi
done
! [ 0 = $err ] && exit $err

# check if network namespace already exists
if ! ip netns list | eno grep -e \\b"$NAME"\\b; then

  print G " * Creating a $NAME namespace..."
  # add network namespace
  ip netns add "$NAME"

  # Create veth link.
  print G " * Creating a veth link..."
  ip link add in-"$NAME" type veth peer name out-"$NAME"

  # Add out to NS.
  print G " * Sharing the veth interface..."
  ip link set out-"$NAME" netns "$NAME"

  ## setup ip address of host interface
  print G " * Setting up IP address of host interface..."
  ip addr add "$IPHOST"/"$NETMASK" dev in-"$NAME"
  ip link set in-"$NAME" up

  # setup ip address of peer
  print G " * Setting up IP address of peer interface..."
  ip netns exec "$NAME" ip addr add "$IPNETNS"/"$NETMASK" dev out-"$NAME"
  ip netns exec "$NAME" ip link set out-"$NAME" up

  # default route
  print G " * Default routing up..."
  ip netns exec "$NAME" ip route add default via "$IPHOST"

  # resolve with tor
  print G " * Resolving via Tor"
  iptables -t nat -A  PREROUTING -i in-"$NAME" -p udp -d "$IPHOST" --dport 53 -j DNAT \
        --to-destination "$IPHOST":"$DNSPORT"

  # traffic througth tor
  print G " * Traffic via Tor..."
  iptables -t nat -A  PREROUTING -i in-"$NAME" -p tcp --syn -j DNAT \
           --to-destination "$IPHOST":"$TRANSPORT"
  iptables -A OUTPUT -m state -o in-"$NAME" --state ESTABLISHED,RELATED -j ACCEPT

  # REJECT all traffic coming from orjail
  # this is needed to avoid reaching other interfaces
  iptables -I INPUT -i in-"$NAME" -p udp --destination "$IPHOST" --dport "$DNSPORT" -j ACCEPT
  iptables -I INPUT -i in-"$NAME" -p tcp --destination "$IPHOST" --dport "$TRANSPORT" -j ACCEPT
  if [[ $HIDDENSERVICE = y ]]; then
    iptables -I INPUT -i in-"$NAME" -p tcp --source "$IPNETNS" --sport "$HSERVICEPORT" -j ACCEPT
    iptables -I INPUT -i in-"$NAME" -p tcp --destination "$IPNETNS" --dport "$HSERVICEPORT" -j ACCEPT
  fi
  # while we inserted the rules above, the DROP rule must be appended instead
  iptables -A INPUT -i in-"$NAME" -j DROP

  # disable forwarding (no packets from here should be forwarded!)
  iptables -I FORWARD -i in-"$NAME" -j DROP
  iptables -I FORWARD -o in-"$NAME" -j DROP

  sysctl -w -q net.ipv4.conf.in-"$NAME".forwarding=0

  # everything coming/redirected from orjail does not have to reach any other interface 
  iptables -t nat -I POSTROUTING 1 \! -o in-"$NAME" -s "$IPHOST"/24 -j RETURN
  iptables -t nat -I PREROUTING 1 \! -i in-"$NAME" -d "$IPHOST"/24 -j RETURN

  # prevent port redirection to be made in orjail
  iptables -t nat -A PREROUTING -i in-"$NAME" -j RETURN

  # prevent external traffic to reach orjail  
  iptables -A INPUT ! -i in-orjail -s "$IPHOST"/24 -j DROP
  iptables -A INPUT ! -i in-orjail -d "$IPHOST"/24 -j DROP

  # execute tor
  print G " * Creating the Tor configuration file..."

  # automatically detect tor version and use appropriate syntax
  TORVERSION="$($TORBIN --version|grep -Eo ' ([0-9.]+)'|xargs)"
  print G " * Tor version is $TORVERSION"

  TORCONFIGFILE=$(mktemp /tmp/torXXXXXX)
  chown "$USERNAME" "$TORCONFIGFILE"

  cat > "$TORCONFIGFILE" <<EOF
  DataDirectory /tmp/orjail-${NAME}
  AutomapHostsSuffixes .onion,.exit
  AutomapHostsOnResolve 1
  PidFile      /tmp/orjail-${NAME}/pid
  User         ${USERNAME}
  VirtualAddrNetworkIPv4 ${IPNETNS}/16
  TransPort ${IPHOST}:${TRANSPORT}
  DNSPort ${IPHOST}:${DNSPORT}
  SOCKSPort 0
EOF

  if [[ "$HIDDENSERVICE" = y ]]; then
    if [[ "$HIDDENSERVICEDIR" ]]; then
      echo "HiddenServiceDir $(realpath "$HIDDENSERVICEDIR")" >> "$TORCONFIGFILE"
    else
      echo "HiddenServiceDir /tmp/orjail-$NAME" >> "$TORCONFIGFILE"
    fi
    echo "HiddenServicePort $HSERVICEPORT $IPNETNS:$HSERVICEPORT" >> "$TORCONFIGFILE"
  fi

  # reuse tor host's cache
  if [ -d "/var/lib/tor" ]; then
  mkdir "/tmp/orjail-$NAME"
  print G " * Copying host's tor cache"
  cp -d -R /var/lib/tor/* "/tmp/orjail-${NAME}/"
  chown -R "$USERNAME" "/tmp/orjail-${NAME}/"
  chmod -R 700 "/tmp/orjail-${NAME}/"
    if [ -f "/tmp/orjail-${NAME}/lock" ]; then
      rm "/tmp/orjail-${NAME}/lock"
    fi
   fi

  # executing tor
  print G " * Executing Tor..."
  $TORBIN --quiet -f "$TORCONFIGFILE" &> /dev/null &
else
  print Y "$NAME network namespace already exists!"
fi

if ! [ $USEFIREJAIL = y ]; then
  RESOLVEFILE=$(mktemp /tmp/resolveXXXXXX)
  print G " * Creating a temporary /etc/resolv.conf ($RESOLVEFILE)..."
  echo "nameserver $IPHOST" > "$RESOLVEFILE"
  chmod a+r "$RESOLVEFILE"
fi

NOSETUPERROR=y
# use firejail as security container
if [ $USEFIREJAIL = y ]; then
  if [ "$SUDOBIN" ]; then
    if [ "${FIREJAILARGS[0]}" ]; then
      $SUDOBIN -u "$USERNAME" "$FIREJAILBIN" "${FIREJAILARGS[@]}" --noroot --private-tmp --quiet --dns="$IPHOST" --netns="$NAME" "$@"
    else
      $SUDOBIN -u "$USERNAME" "$FIREJAILBIN" --noroot --private-tmp --quiet --dns="$IPHOST" --netns="$NAME" "$@"
    fi
  else
    su "$USERNAME" -c "$FIREJAILBIN ${FIREJAILARGS[*]} --dns=$IPHOST --netns=$NAME $*"
  fi
else #or without
  ip netns exec "$NAME" \
    unshare --ipc --fork --pid --mount --mount-proc \
    "$0" --inside "$USERNAME" "$RESOLVEFILE" "$VERBOSE" "$@"
fi


# All done!
